# server/server.py
import os
import asyncio
from grpc import aio

# generated by protoc (see note below)
from server.microservices.data_generator.gen import market_data_pb2 as pb
from server.microservices.data_generator.gen import market_data_pb2_grpc as rpc

from server.microservices.data_generator.engine import OrderBookEngine

class MarketDataService(rpc.MarketDataServicer):
    def __init__(self):
        self._engines = {}

    def _get_engine(self, symbol: str) -> OrderBookEngine:
        sym = symbol or "FAKE"
        if sym not in self._engines:
            self._engines[sym] = OrderBookEngine()
        return self._engines[sym]

    async def StreamOrderBook(self, request, context):
        symbol = request.symbol or "FAKE"
        depth  = request.depth or 10
        interval = float(os.getenv("MD_INTERVAL_SEC", "0.1"))  # 10 Hz default

        engine = self._get_engine(symbol)
        while True:
            ob = engine.step(symbol=symbol, depth=depth)
            bids = [pb.PriceLevel(price=p, size=s) for p, s in ob["bids"]]
            asks = [pb.PriceLevel(price=p, size=s) for p, s in ob["asks"]]
            yield pb.OrderBookUpdate(
                symbol=symbol,
                ts_unix_ms=ob["ts_unix_ms"],
                bids=bids,
                asks=asks,
            )
            await asyncio.sleep(interval)

async def main():
    port = int(os.getenv("GRPC_PORT", "50051"))
    server = aio.server()
    rpc.add_MarketDataServicer_to_server(MarketDataService(), server)
    server.add_insecure_port(f"[::]:{port}")
    await server.start()
    print(f"âœ… gRPC MarketData listening on :{port}")
    await server.wait_for_termination()

if __name__ == "__main__":
    asyncio.run(main())

